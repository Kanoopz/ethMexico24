"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateTransactionMultisigECDSA = exports.populateTransactionECDSA = exports.signPayloadWithMultipleECDSA = exports.signPayloadWithECDSA = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
/**
 * Signs the `payload` using an ECDSA private key.
 *
 * @param payload The payload that needs to be signed.
 * @param secret The ECDSA private key.
 *
 * @example Sign EIP712 transaction hash.
 *
 * import { EIP712Signer, types, utils } from "zksync-ethers";
 *
 * const PRIVATE_KEY = "<PRIVATE_KEY>";
 *
 * const tx: types.TransactionRequest = {
 *   chainId: 270,
 *   from: ADDRESS,
 *   to: "<RECEIVER>",
 *   value: 7_000_000_000,
 * };
 *
 * const txHash = EIP712Signer.getSignedDigest(tx);
 * const signature = await utils.signPayloadWithECDSA(txHash, PRIVATE_KEY);
 *
 * @example Sign message hash.
 *
 * import { utils } from "zksync-ethers";
 * import { ethers } from "ethers";
 *
 * const PRIVATE_KEY = "<PRIVATE_KEY>";
 *
 * const message = 'Hello World!';
 * const messageHash = ethers.utils.hashMessage(message);
 *
 * const signature = await utils.signPayloadWithECDSA(messageHash, PRIVATE_KEY);
 *
 * @example Sign typed data hash.
 *
 * import { utils } from "zksync-ethers";
 * import { ethers } from "ethers";
 *
 * const PRIVATE_KEY = "<PRIVATE_KEY>";
 *
 * const typedDataHash = ethers.utils._TypedDataEncoder.hash(
 *   {name: 'Example', version: '1', chainId: 270},
 *   {
 *     Person: [
 *       {name: 'name', type: 'string'},
 *       {name: 'age', type: 'uint8'},
 *     ],
 *   },
 *   {name: 'John', age: 30}
 * );
 * const signature = await utils.signPayloadWithECDSA(typedDataHash, PRIVATE_KEY);
 */
const signPayloadWithECDSA = async (payload, secret) => {
    return ethers_1.ethers.utils.joinSignature(new ethers_1.ethers.Wallet(secret)._signingKey().signDigest(payload));
};
exports.signPayloadWithECDSA = signPayloadWithECDSA;
/**
 * Signs the `payload` using multiple ECDSA private keys.
 * The signature is generated by concatenating signatures created by signing with each key individually.
 * The length of the resulting signature should be `secrets.length * 65 + 2`.
 *
 * @param payload The payload that needs to be signed.
 * @param secret The list of the ECDSA private keys.
 *
 * @throws {Error} If the `secret` is not an array of at least two elements
 *
 * @example Sign EIP712 transaction hash.
 *
 * import { EIP712Signer, types, utils } from "zksync-ethers";
 *
 * const PRIVATE_KEY1 = "<PRIVATE_KEY1>";
 * const PRIVATE_KEY2 = "<PRIVATE_KEY2>";
 *
 * const tx: types.TransactionRequest = {
 *   chainId: 270,
 *   from: ADDRESS,
 *   to: "<RECEIVER>",
 *   value: 7_000_000_000,
 * };
 *
 * const txHash = EIP712Signer.getSignedDigest(tx);
 * const signature = await utils.signPayloadWithMultipleECDSA(txHash, [PRIVATE_KEY1, PRIVATE_KEY2]);
 *
 * @example Sign message hash.
 *
 * import { utils } from "zksync-ethers";
 * import { ethers } from "ethers";
 *
 * const PRIVATE_KEY1 = "<PRIVATE_KEY1>";
 * const PRIVATE_KEY2 = "<PRIVATE_KEY2>";
 *
 * const message = 'Hello World!';
 * const messageHash = ethers.utils.hashMessage(message);
 *
 * const signature = await utils.signPayloadWithMultipleECDSA(messageHash, [PRIVATE_KEY1, PRIVATE_KEY2]);
 *
 * @example Sign typed data hash.
 *
 * import { utils } from "zksync-ethers";
 * import { ethers } from "ethers";
 *
 * const PRIVATE_KEY1 = "<PRIVATE_KEY1>";
 * const PRIVATE_KEY2 = "<PRIVATE_KEY2>";
 *
 * const typedDataHash = ethers.utils._TypedDataEncoder.hash(
 *   {name: 'Example', version: '1', chainId: 270},
 *   {
 *     Person: [
 *       {name: 'name', type: 'string'},
 *       {name: 'age', type: 'uint8'},
 *     ],
 *   },
 *   {name: 'John', age: 30}
 * );
 * const signature = await utils.signPayloadWithMultipleECDSA(typedDataHash, [PRIVATE_KEY1, PRIVATE_KEY2]);
 */
const signPayloadWithMultipleECDSA = async (payload, secret) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error('Multiple keys are required for multisig signing!');
    }
    const signatures = secret.map(key => 
    // Note, that `signMessage` wouldn't work here, since we don't want
    // the signed hash to be prefixed with `\x19Ethereum Signed Message:\n`
    ethers_1.ethers.utils.joinSignature(new ethers_1.ethers.Wallet(key)._signingKey().signDigest(payload)));
    return ethers_1.ethers.utils.hexlify(ethers_1.ethers.utils.concat(signatures));
};
exports.signPayloadWithMultipleECDSA = signPayloadWithMultipleECDSA;
/**
 * Populates missing properties meant for signing using an ECDSA private key:
 *
 * - Populates `from` using the address derived from the ECDSA private key.
 * - Populates `nonce` via `provider.getTransactionCount(tx.from, "pending")`.
 * - Populates `gasLimit` via `provider.estimateGas(tx)`. If `tx.from` is not EOA, the estimation is done with address
 * derived from the ECDSA private key.
 * - Populates `chainId` via `provider.getNetwork()`.
 * - Populates `type` with `utils.EIP712_TX_TYPE`.
 * - Populates `value` by converting to `BigNumber` if set, otherwise to `BigNumber.from(0)`.
 * - Populates `data` with `0x`.
 * - Populates `customData` with `{factoryDeps=[], gasPerPubdata=utils.DEFAULT_GAS_PER_PUBDATA_LIMIT}`.
 *
 * @param tx The transaction that needs to be populated.
 * @param [secret] The ECDSA private key used for populating the transaction.
 * @param [provider] The provider is used to fetch data from the network if it is required for signing.
 *
 * @throws {Error} Requires `provider` to be set.
 *
 * @example
 *
 * import { Provider, types, utils } from "zksync-ethers";
 *
 * const PRIVATE_KEY = "<PRIVATE_KEY>";
 *
 * const provider = Provider.getDefaultProvider(types.Network.Sepolia);
 *
 * const populatedTx = await utils.populateTransactionECDSA(
 *   {
 *     chainId: 270,
 *     to: "<RECEIVER>",
 *     value: 7_000_000_000,
 *   },
 *   PRIVATE_KEY,
 *   provider
 * );
 */
const populateTransactionECDSA = async (tx, secret, provider) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var _l, _m;
    if (!provider) {
        throw new Error('Provider is required but is not provided!');
    }
    const populatedTx = { ...tx };
    populatedTx.type = utils_1.EIP712_TX_TYPE;
    (_a = populatedTx.chainId) !== null && _a !== void 0 ? _a : (populatedTx.chainId = (await provider.getNetwork()).chainId);
    populatedTx.value = populatedTx.value
        ? ethers_1.BigNumber.from(populatedTx.value)
        : ethers_1.BigNumber.from(0);
    (_b = populatedTx.data) !== null && _b !== void 0 ? _b : (populatedTx.data = '0x');
    (_c = populatedTx.gasPrice) !== null && _c !== void 0 ? _c : (populatedTx.gasPrice = await provider.getGasPrice());
    populatedTx.customData = (_d = tx.customData) !== null && _d !== void 0 ? _d : {};
    (_e = (_l = populatedTx.customData).gasPerPubdata) !== null && _e !== void 0 ? _e : (_l.gasPerPubdata = utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT);
    (_f = (_m = populatedTx.customData).factoryDeps) !== null && _f !== void 0 ? _f : (_m.factoryDeps = []);
    if (populatedTx.from) {
        const isContractAccount = ethers_1.ethers.utils.arrayify(await provider.getCode(populatedTx.from)).length !==
            0;
        if (isContractAccount) {
            // Gas estimation does not work when initiator is contract account (works only with EOA).
            // In order to  estimation gas, the transaction's from value is replaced with signer's address.
            (_g = populatedTx.gasLimit) !== null && _g !== void 0 ? _g : (populatedTx.gasLimit = await provider.estimateGas({
                ...populatedTx,
                from: new ethers_1.ethers.Wallet(secret).address,
            }));
        }
    }
    (_h = populatedTx.from) !== null && _h !== void 0 ? _h : (populatedTx.from = new ethers_1.ethers.Wallet(secret).address);
    (_j = populatedTx.gasLimit) !== null && _j !== void 0 ? _j : (populatedTx.gasLimit = await provider.estimateGas(populatedTx));
    (_k = populatedTx.nonce) !== null && _k !== void 0 ? _k : (populatedTx.nonce = await provider.getTransactionCount(populatedTx.from, 'pending'));
    return populatedTx;
};
exports.populateTransactionECDSA = populateTransactionECDSA;
/**
 * Populates missing properties meant for signing using multiple ECDSA private keys.
 * It uses {@link populateTransactionECDSA}, where the address of the first ECDSA key is set as the `secret` argument.
 *
 * @param tx The transaction that needs to be populated.
 * @param [secret] The list of the ECDSA private keys used for populating the transaction.
 * @param [provider] The provider is used to fetch data from the network if it is required for signing.
 *
 * @throws {Error} The `secret` must be an array of at least two elements.
 *
 * @example
 *
 * import { Provider, types, utils } from "zksync-ethers";
 *
 * const PRIVATE_KEY1 = "<PRIVATE_KEY1>";
 * const PRIVATE_KEY2 = "<PRIVATE_KEY2>";
 *
 * const provider = Provider.getDefaultProvider(types.Network.Sepolia);
 *
 * const populatedTx = await utils.populateTransactionMultisigECDSA(
 *   {
 *     chainId: 270,
 *     to: "<RECEIVER>",
 *     value: 7_000_000_000,
 *   },
 *   [PRIVATE_KEY1, PRIVATE_KEY2],
 *   provider
 * );
 */
const populateTransactionMultisigECDSA = async (tx, secret, provider) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error('Multiple keys are required to build the transaction!');
    }
    // populatesTransaction estimates gas which accepts only one address, so the first signer is chosen.
    return (0, exports.populateTransactionECDSA)(tx, secret[0], provider);
};
exports.populateTransactionMultisigECDSA = populateTransactionMultisigECDSA;
//# sourceMappingURL=smart-account-utils.js.map